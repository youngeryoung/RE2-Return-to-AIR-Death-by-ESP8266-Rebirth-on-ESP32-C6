 * 本项目存在AI参与构建，技术报告白皮书由AI阅读代码后生成
 * 本项目为参加学校新人赛，立项晚，工期短，比赛前两天又临时更换单片机选型，带来了诸多不确定性，如果您在使用过程中遇到了问题，那大概率是我的问题。
 * 上传的文件不包含生成的游戏脚本及资源文件
 * 此处为资源游戏Dream篇前三天+空视角前三天的资源文件：https://www.123684.com/s/LvggTd-Pyf6H?pwd=TaRO# 提取码:TaRO
   
---

# **《RE2:再次从零开始的AIR ESP32C6移植》项目技术白皮书**

---

### **摘要**

本项目旨在将经典视觉小说《AIR》的完整核心体验，移植至以 ESP32-C6 为核心的现代低功耗、资源受限的嵌入式平台。项目前身曾因目标平台（ESP8266）内存与性能的严重制约而中止，现通过对架构的彻底重构与深度优化得以“重生”。为达成此目标，我们设计并实现了一套完整的、覆盖内容创作全链路的**离线编译（Ahead-Of-Time, AOT）** 与**轻量级实时运行时（Lightweight Real-time Runtime）** 架构。本报告将详细阐述该架构的设计哲学、技术规范、关键模块实现及其背后的优化策略，包括数据 IO 模型、基于中断的非阻塞音频子系统、健壮的存读档机制以及高度自动化的资产预处理管道。

### **鸣谢 (Acknowledgements)**

本项目的诞生与成功，离不开开源社区的无私奉献与奠基。我们站在巨人的肩膀上，得以在此探索嵌入式视觉小说的可能性。我们谨向以下开源项目及其才华横溢的作者们，致以最诚挚的感谢与崇高的敬意：

*   **字体渲染引擎 (uFont)**: 由 **AntonVanke** 开发的 [MicroPython-uFont](https://github.com/AntonVanke/MicroPython-uFont) 及其配套的 uFont-Tools。这个项目为在资源受限的 MicroPython 环境中高效显示自定义位图字体提供了坚实、可靠的基础。

*   **像素字体 (Fusion Pixel Font)**: 由 **TakWolf** 精心创作的 [fusion-pixel-font](https://github.com/TakWolf/fusion-pixel-font)。这款兼具美感与高辨识度的像素字体，是本项目能够在低分辨率屏幕上实现清晰文本显示的点睛之笔。

*   **AI音乐转录模型**: 基于**字节跳动（Bytedance）AI Lab**研究成果并开源的 [piano_transcription](https://github.com/bytedance/piano_transcription)。这个强大的深度学习模型，将繁琐的音乐扒谱工作带入了 AI 辅助创作的新时代，极大地提升了本项目音频内容的制作效率。

---

### **第一章：系统总体架构**

#### **1.1 设计哲学**

面对从 ESP8266 到 ESP32-C6 的平台迁移，本项目在继承原有设计思想的基础上，根据硬件能力的提升进行了关键的演进，确立了三大核心设计原则：

1.  **彻底的离线/在线分离**: 坚持将所有非实时必需的、计算密集型的任务（资源转换、文本布局、脚本编译）从 MCU 剥离，转移至 PC 端的 AOT 工具链完成。MCU 运行时只负责确定性的、高效的二进制数据呈现与交互。

2.  **数据驱动的“虚拟机”模型**: 运行时引擎与游戏内容完全解耦。所有剧情、图形、音频和时序均由外部的预编译数据文件驱动，使得运行时本身是一个通用的、可复用的“视觉小说虚拟机”。

3.  **主循环与中断驱动的混合调度**: 核心交互逻辑基于一个非阻塞的主循环状态机（FSM）。而对时序要求极高的音频播放任务，则完全交由硬件定时器中断进行抢占式调度，确保了在任何情况下音频的流畅性不受主循环负载的影响。

#### **1.2 软件架构分层**

系统在逻辑上分为清晰的层次，以实现高内聚、低耦合：

*   **PC端资产预处理工具链**: 编译器、优化器、资源打包器。
*   **设备端运行时 (MicroPython)**:
    *   **应用层 (`main.py`)**: 顶层模式状态机（欢迎/标题/OP/游戏）与主循环调度器。
    *   **逻辑层 (`engine.py`, `cg_player.py`)**: 负责具体的业务逻辑实现（游戏脚本解析/OP动画播放）。
    *   **服务层 (`buzzer_player.py`, `data_reader.py`)**: 提供底层的音频播放和数据块访问服务。
    *   **硬件抽象层 (`buttons.py`, `ufont.py`, `ssd1306.py`, `utils.py`)**: 封装与硬件和底层绘图相关的交互。

---

### **第二章：PC 端资产预处理工具链详解**

本项目的核心思想是将运行时（Runtime）的复杂度降至最低。为此，我们构建了一套基于 Python 的自动化资产处理管道，负责将人类可读的源文件转换为设备可直接消费的、高度优化的二进制数据。

#### **2.1 音频内容管道：从 MIDI 到非阻塞音符流**

该管道的目标是生成引擎专用的 `.msc` 格式，其设计完全服务于 `buzzer_player.py` 的流式读取和中断驱动模型。

1.  **AI 辅助转录与人工编排**: 使用 `piano-transcription-inference` 库将源音频批量转录为 MIDI 文件，作为扒谱的基准。随后，在标准 DAW（数字音频工作站）软件中进行人工精修，将复杂的和弦结构简化、重排为两个独立的单音轨（Monophonic），以匹配双通道蜂鸣器的物理能力。
2.  **MSC 格式编译 (`midi_to_msc_compiler.py`)**: 此脚本是音频管道的核心。
    *   **时间量化**: 脚本首先读取 MIDI 文件中的 `ticks_per_beat` 和 BPM 信息，计算出引擎使用的最小时间单位——**64分音符**——所对应的微秒数 (`_64th_note_duration_us`)。所有音符的起始和结束时间点都将被量化到这个时间网格上，转换为整数时间戳。
    *   **数据结构**: 每个 MIDI 音符被转换为一个 6 字节的二进制记录，其 `struct` 格式为 `<HHBB`，分别代表：
        *   `Start_Timestamp` (16位无符号整数): 音符起始时间，以 64 分音符为单位。
        *   `End_Timestamp` (16位无符号整数): 音符结束时间。
        *   `Pitch` (8位无符号整数): MIDI 标准音高值。
        *   `Normalized_Velocity` (8位无符号整数): 将 MIDI 的力度值 (0-127) **非线性地**映射到 0-255 的范围内，以在蜂鸣器上模拟更自然的音量变化。

#### **2.2 图像内容管道：基于 OpenCV 的高级视觉处理**

为在 128x64 的单色屏幕上还原《AIR》的美术风格，我们放弃了简单的图像缩放，转而采用基于轮廓分析的算法。

1.  **背景图处理 (`trbg.py`)**:
    *   **自适应二值化底图**: 首先，将高分辨率源图缩放至目标尺寸，并使用 `cv2.adaptiveThreshold` 生成一个保留了基本光影关系的二值化底图。
    *   **Canny 边缘检测**: 在**高分辨率**的灰度图上执行 Canny 边缘检测，提取出比在低分辨率图上直接提取更精确、更连续的物体轮廓。
    *   **轮廓叠加**: 将高分辨率的边缘轮廓按比例缩小，然后作为“线条”绘制到底图之上，通过“描边”的方式强化了场景的关键结构和视觉焦点。
2.  **人物立绘处理 (`trcg.py`)**: 针对人物立绘这种对线条要求极高的图像，我们采用了更纯粹的轮廓重绘算法。
    *   在高分辨率图上提取所有轮廓的**矢量坐标点**。
    *   按目标尺寸（24x48）计算缩放比例，将所有坐标点进行线性变换。
    *   在一个全黑的低分辨率画布上，使用 `cv2.drawContours` **重新绘制**这些缩放后的轮廓。这相当于在低分辨率下重新“画”了一遍人物，效果远胜于对位图的直接缩放。

#### **2.3 脚本编译器 (`preprocess.py`)：一个小型 DSL 编译器**

此脚本是整个工具链的大脑，负责将高级的、人类可读的剧本语言，编译为设备可直接执行的低级指令集。

1.  **第一遍扫描 (Pass 1: Symbol Table Construction)**:
    *   遍历整个原始脚本，构建一个**符号表**（`label_to_output_line`），记录所有 `^LABEL` 指令及其在**最终输出脚本中**的预期行号。
    *   同时，搜集所有被引用的资源文件名（背景、立绘、音乐），并为每类资源建立一个从名称到整数索引的映射（`backgrounds_map`, `characters_map`），最终写入 `assets_manifest.json`。
2.  **第二遍扫描 (Pass 2: Control Flow Optimization)**:
    *   分析所有 `^JUMP` 指令，解析形如 `^JUMP [LABEL_A]` 后紧跟 `^LABEL [LABEL_A]` `^JUMP [LABEL_B]` 这样的**跳转链**。
    *   通过递归或迭代查找，将所有指向跳转指令的标签，直接解析到它们的最终目的地，减少了设备运行时的无效跳转。
3.  **第三遍扫描 (Pass 3: Code Generation & Emission)**:
    *   逐行读取源脚本，进行最终的“代码生成”：
        *   **文本布局**: 对所有对话行，调用**高级文本布局引擎**。该引擎根据预设的屏幕宽度和中英文字符宽度（全角为2，半角为1），并依据中文标点符号的避头尾规则，自动将长句分割为多页或多行，并插入 `\n`。
        *   **指令重写**: 将所有资源引用（如 `^BG air`）替换为 `assets_manifest.json` 中对应的整数索引（如 `^BG 0`）。将所有跳转目标（如 `^JUMP [START]`）替换为符号表中记录的最终行号（如 `^JUMP 1`）。
    *   **文件输出**:
        *   在以文本模式 (`'w', newline='\n'`) 写入 `final_script.txt` 的同时，实时计算每行写入的字节长度。
        *   将每行的起始字节偏移量，使用 `struct.pack('<I', offset)` 打包成一个 32 位无符号小端序整数，并写入 `final_script.idx`。`newline='\n'` 的使用是跨平台兼容性的关键，它确保了偏移量计算的绝对精确。

---

### **第三章：设备端运行时详解**

#### **3.1 核心游戏引擎 (`engine.py`)**

1.  **内存索引 (`In-Memory Index`)**: 作为对 ESP8266 版本“块缓存”模型的彻底升级，`engine.py` 在 `__init__` 阶段将整个 `.idx` 索引文件（约 24 KB）一次性加载到 RAM 中的一个 `bytes` 对象 (`self._index_data`)。
    *   **根本性地解决 IO 问题**: 此设计彻底消除了运行时对索引文件的任何 `seek`/`read` 操作。经调试发现，在 MicroPython 环境下，对不同文件句柄的快速、交错 `seek` 存在不可靠性，是导致 `UnicodeError` 和状态错乱的根源。将索引置于内存中，使得行偏移量的获取变成了一个纯粹的、无副作用的内存操作 (`struct.unpack_from`)。
    *   **性能优势**: 从 RAM 中获取偏移量远快于从 Flash 文件系统，提升了脚本的执行速度。
2.  **主更新循环 (`update`)**: 这是引擎的核心脉搏，一个基于 `_wait_mode` 标志的精确状态机。
    *   **状态管理**: `_wait_mode` 的值（如 `'none'`, `'confirm'`, `'choice'`, `'auto'`, `'menu'`, `'pending_load'`）决定了 `update` 函数在每一帧的行为。
    *   **控制流**: 当 `_wait_mode` 为 `'none'` 时，主执行块被激活，它会读取并处理当前 `_pc` 指向的脚本行。如果该指令是非阻塞的（如 `^BG`），`_wait_mode` 保持不变，`_pc` 在循环末尾自动递增。如果指令是阻塞的（如对话），`_handle_dialogue` 会将 `_wait_mode` 设为 `'confirm'`。
    *   **事件驱动的 `_pc` 推进**: 在所有等待模式下（`'confirm'`, `'auto'`），`_pc` 的推进不再由主执行块负责，而是由相应的事件处理逻辑（如检测到 `confirm_pressed`）在解除等待状态的同时，显式地执行 `self._pc += 1`。这种设计确保了 `_pc` 的状态转换是精确且无二义性的。

#### **3.2 实时音频子系统 (`buzzer_player.py`)**

1.  **架构：主循环-中断解耦**: 通过 `machine.Timer` 将音频处理置于硬件中断上下文中，实现了与主游戏循环的完全解耦和抢占式调度。这保证了即使主循环因文件 IO 或复杂绘图而产生延迟，音频的节拍也绝对稳定。
2.  **中断安全 (Interrupt Safety)**: 这是本项目能够稳定运行的最终关键。经过深度调试，所有在中断上下文（`_timer_callback` 及其调用的 `_process_bgm`, `_process_sfx` 等）中可能引起阻塞或与主循环产生**竞争条件**的操作，特别是 `print()`，都已被彻底移除。在中断中执行 `print()` 会导致 UART I/O 阻塞，严重破坏系统时序，是导致之前版本随机卡死和状态崩溃的根源。
3.  **流式播放与双缓冲**:
    *   **数据流**: Flash (`.msc` file) -> `poll()` -> RAM (Buffer A/B) -> `_timer_callback` -> Buzzer PWM
    *   **协作机制**: 主循环中的 `poll()` 方法是一个低优先级的“填充”任务，它负责检查并填充两个缓冲区中当前“非活动”的那个。`_timer_callback` 是一个高优先级的“消耗”任务，它只从“活动”缓冲区中读取音符数据。当活动缓冲区耗尽时，它会立刻切换“活动”与“非活动”缓冲区的角色，并等待 `poll()` 在未来的某个时间点将那个刚变空的缓冲区再次填满。
4.  **SFX 播放与仲裁**: `play_sfx()` 的调用是一个非阻塞的事件提交。它会将一个音效任务（一个包含频率和时长的音符列表）放入 `_sfx_queue`，并将对应声道的模式设为 `_MODE_SFX`。在 `_timer_callback()` 中，会优先检查通道模式。如果是 `_MODE_SFX`，则执行 `_process_sfx` 逻辑，临时忽略 BGM；当 SFX 播放完毕，模式会自动恢复为 `_MODE_BGM`，实现了 BGM 的无缝恢复。

#### **3.3 健壮的存读档系统**

1.  **数据完整性**: 存档数据在写入时，会先计算其 CRC32 校验和并追加到文件末尾。在读取时，会重新计算并比对校验和，确保文件在存储过程中没有损坏。
2.  **“延迟读档”状态机 (`'pending_load'`)**: 为了解决从标题菜单（非游戏运行状态）直接读档进入游戏时，因状态切换不完全导致的时序冲突，我们设计了一个创新的“延迟读档”机制。
    *   从标题菜单调用 `load_state(True)` 时，引擎并**不立即**执行读档，而是将 `_is_running` 设为 `True`，并将 `_wait_mode` 设为 `'pending_load'`。
    *   这会促使 `main.py` 的主循环安全地切换到 `MODE_GAME`。
    *   在 `MODE_GAME` 的第一帧 `update()` 调用中，引擎检测到 `'pending_load'` 状态，此时才执行真正的 `load_state(False)` 逻辑。
    *   这个分两步走的过程，确保了读档操作在一个已经稳定建立的游戏循环环境中执行，完美地解决了状态初始化的竞争条件问题。
3.  **数据类型安全**: 在 `save_state` 和 `load_state` 的实现中，增加了严格的数据类型检查与转换，确保了在打包和解包 `struct` 时不会因 `NoneType` 或 `str`/`int` 不匹配而引发 `TypeError`。

---

### **第四章：结论**

`AIR on ESP32-C6` 项目的成功，不仅是经典作品在新型硬件上的重现，更是一次在嵌入式系统复杂应用开发领域的深度实践。通过将复杂的计算任务进行 AOT 编译，并设计一个数据驱动、主循环与中断混合调度的实时运行时，我们在硬件资源的“方寸之地”上，成功地构建了一个功能完备且体验流畅的复杂应用。

从 ESP8266 的失败到 ESP32-C6 的重生，项目在**IO 模型（从块缓存到内存索引）**、**并发控制（解决中断安全问题）**和**状态管理（解决读档时序冲突）**等方面的关键技术演进，为未来在类似受限平台上的高级应用开发提供了极具价值的参考范例和一套可复用的解决方案。
